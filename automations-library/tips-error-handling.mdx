---
title: "Error Handling"
description: "Build resilient automations that handle failures gracefully"
---

Automations run unattended, so they need to handle errors gracefully. Here's how to build resilient workflows.

## Retry Logic

API calls can fail temporarily. Build in retries for transient failures.

```text
Try up to 3 times:
  - Fetch data from API
  - If successful, proceed
  - If rate limited, wait 60 seconds and retry
  - If all attempts fail, log error and notify team
```

## Fallback Behavior

When the primary approach fails, have a backup plan.

```text
Try to post to #team-updates
If channel doesn't exist:
  - Post to #general instead
  - Notify admin about missing channel
```

## Partial Success

Don't let one failure stop the whole automation. Process items independently.

```text
For each PR in the list:
  - Try to process the PR
  - If processing fails:
    - Log the error with PR number
    - Continue with remaining PRs
  - Track success/failure counts

At the end:
  - Report: "Processed 8/10 PRs successfully"
  - List failed items for manual review
```

## Dry Run Mode

Add a flag to test automations without making real changes.

```text
If DRY_RUN mode:
  - Log what would be done
  - Show the Slack message that would be posted
  - List the PRs that would be created
  - Don't make actual changes
Otherwise:
  - Execute normally
```

## Testing Strategies

### Use Test Markers

Isolate test runs from production:

```text
Only process items with label "automation-test"
This keeps testing separate from real data
```

### Incremental Testing

Build up complexity gradually:

```text
Phase 1: Just fetch and log data
Phase 2: Add filtering logic
Phase 3: Add action logic (comments, labels)
Phase 4: Enable posting to real channels
```

### Test Channels

Use dedicated test channels before going live:

```text
Development: Post to #automation-test
Staging: Post to #team-updates-test
Production: Post to #team-updates
```

## Debugging Tips

### Log Decision Points

Add logging at key moments to understand what happened:

```text
Log: "Found 15 PRs merged in last 24 hours"
Log: "After filtering: 8 PRs (excluded drafts and bots)"
Log: "Grouped into: 3 features, 4 bugfixes, 1 chore"
Log: "Posted to #changelog successfully"
```

### Include Timestamps

Timestamps help correlate logs with events:

```text
[2024-01-15 09:00:03] Starting daily changelog automation
[2024-01-15 09:00:05] Fetched 15 PRs from GitHub
[2024-01-15 09:00:07] Posted summary to Slack
[2024-01-15 09:00:07] Completed in 4 seconds
```

### Save Raw Responses

For complex debugging, preserve API responses:

```text
If DEBUG mode:
  - Save raw GitHub API response to logs
  - Save formatted message before posting
  - Include response status codes
```

## Security Considerations

### Never Log Secrets

Don't include tokens or sensitive data in logs:

```text
Log: "Using API key ending in ...x7k9"  ✓
Log: "Using API key sk-abc123..."       ✗
```

### Validate Input

Check data before using it:

```text
Before posting message:
- Check message doesn't contain API keys or tokens
- Validate URLs are from trusted domains
- Ensure content length is reasonable
```

### Limit Scope

Request only the permissions your automation needs. Don't use admin tokens for read-only operations.
